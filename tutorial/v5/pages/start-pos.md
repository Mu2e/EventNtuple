# Plotting MC Truth Information of the Track

## Objectives

In this exercise, you will:

* learn about the leaves of the ```demmcsim``` branch,
* learn the difference between a track primary and an event primary, and
* plot the starting positions of the conversion electrons

## Contents

* [Common Introduction](#Common-Introduction)
* [ROOT](#ROOT)
* [Python](#Python)
* [Additional Exercises](#Additional-Exercises)

## Common Introduction
The conversion electrons we are looking at result from a chain of simulations all the way through to the proton-on-target. This chain of particles is stored in the ```demmcsim``` branch. In the [next exercise](genealogy.md) we will follow this chain but in this exercise we learn about the leaves of this branch and plot the starting positions of the conversion electrons.

Like the ```demfit``` branch we have seen, the ```demmcsim``` branch is an array. Each element in the array contains information of a particle in this genealogy (such as momentum or position) when the particle was created. 

The ```demmcsim``` branch also contains each particle's relation to the "track primary" and the "event primary". The track primary is the particle that produced the track, and the event primary is the particle that was the focus of the simulation. For example, in the dataset we are looking at, the event primary is the conversion electron. In the majority of events, the conversion electron is also the track primary. However, we do see tracks that were generated by a particle in the background frame and so, in this case, the event primary is not the same as the track primary. One other common example is cosmic datasets. There, the event primary is the cosmic ray shower particle which is generated by CORSIKA (or CRY), which is rarely the particle that has been reconstructed.

The leaves that contains this relationship information are the ```trkrel``` and ```prirel``` leaves for the track primary and the event primary respectively. These are stored as type [MCRelationship](https://github.com/Mu2e/Offline/blob/v10_23_02/MCDataProducts/inc/MCRelationship.hh), which contains two variables:

* ```rel``` is the named relationship as given by the [enum](https://github.com/Mu2e/Offline/blob/91d1cfb24bca4f12c656dd2f8c1cd026c2f03cd4/MCDataProducts/inc/MCRelationship.hh#L19) (e.g. same = 0, child = 1, parent = 2)
* ```rem``` is how many generations removed the particle is from the track / event primary (e.g. rem = 1 is one generation away)

In this exercise, we will focus on the event primary and so have a cut like ```prirel._rem == 0```.

## ROOT

In ROOT, let's open the file, get the tree, and create a TCanvas as before:

```
TChain* trkana = new TChain("TrkAna/trkana");

std::ifstream input_filelist("filelists/nts.mu2e.CeEndpointMix1BBSignal.Tutorial_2024_03.list");
if (input_filelist.is_open()) {
  std::string filename;
  while(std::getline(input_filelist,filename)) {
    trkana->Add(filename.c_str());
  }
  input_filelist.close();
}


TCanvas* c1 = new TCanvas("c1", "c1");
c1->SetGridx(true);
c1->SetGridy(true);
```

Now we can draw the X-Y starting position of the conversion electrons like this:

```
  TH2D* hist = new TH2D("hist", "", 100-100,100, 200,-100,100)
  trkana->Draw("demmcsim.pos.y():demmcsim.pos.x()>>hist", "demmcsim.prirel._rem==0", "COLZ");
```

where ```COLZ``` tells ROOT to draw with a color map. Note that the coordinate system used by TrkAna is the detector coordinate system (origin = center of tracker) and not the global Mu2e coordinate system (origin = center of TS3).

You will see the end-on view of the stopping target with the hole in the middle for the beam flash to pass through.


## Python

In python, we can set up as normal but we only need to read in the ```demmcsim``` branch:

```
import uproot
import matplotlib.pyplot as plt
import numpy as np
import awkward as ak

for batch, report in uproot.iterate(files=wildcarded_dir+":TrkAna/trkana", filter_name=["/demmcsim[.]*/"], step_size="10 MB", report=True):
    print(report)


fig, ax = plt.subplots(1,1)
```

Before the iterate loop, we will create arrays for the x and y positions of the conversion electrons:

```
start_pos_x=[]
start_pos_y=[]
```

Within the iterate loop, we just need a mask to get the event primary and fill our arrays:

```
    pri_mask = (batch['demmcsim.prirel._rem']==0)

    start_pos_x = np.append(start_pos_x, ak.flatten(batch['demmcsim.pos.fCoordinates.fX'][(pri_mask)]))
    start_pos_y = np.append(start_pos_y, ak.flatten(batch['demmcsim.pos.fCoordinates.fY'][(pri_mask)]))
```

Finally, we can plot a 2D histogram like this:

```
ax.hist2d(start_pos_x.to_numpy(), start_pos_y.to_numpy(), bins=200, range=[[-100,100],[-100,100]], cmin=0.1)
```

Note that ```hist2d``` does not like awkward arrays and so we have to convert to numpy arrays when plotting. Also, the ```cmin=0.1``` is optional and just makes matplotlib not use any color if a bin has zero entries.

## Additional Exercises
Here are some additional exercises, you might want to try:

* try plotting the start position of the track primary rather than the event primary
* try plotting the MC true energy loss of the conversion electron
    * i.e. compare the momentum in the ```demmcsim``` branch with the momentum in the ```demmcvd``` branch

Last Page: [Plotting Local Track Information](mom-res.md)

Next Page: [Plotting MC Truth Information of Ancestor Particles](genealogy.md)
